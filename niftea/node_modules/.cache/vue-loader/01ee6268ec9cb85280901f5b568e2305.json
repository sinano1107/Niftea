{"remainingRequest":"/Users/choumasateru/Desktop/development_direction/vue/niftea/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/choumasateru/Desktop/development_direction/vue/niftea/src/components/Timeline.vue?vue&type=style&index=0&id=7f3aebf1&scoped=true&lang=css&","dependencies":[{"path":"/Users/choumasateru/Desktop/development_direction/vue/niftea/src/components/Timeline.vue","mtime":1578226723254},{"path":"/Users/choumasateru/Desktop/development_direction/vue/niftea/node_modules/css-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/choumasateru/Desktop/development_direction/vue/niftea/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":499162500000},{"path":"/Users/choumasateru/Desktop/development_direction/vue/niftea/node_modules/postcss-loader/src/index.js","mtime":499162500000},{"path":"/Users/choumasateru/Desktop/development_direction/vue/niftea/node_modules/vuetify-loader/lib/loader.js","mtime":1574476662000},{"path":"/Users/choumasateru/Desktop/development_direction/vue/niftea/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/choumasateru/Desktop/development_direction/vue/niftea/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgouY29udGVudCB7CiAgd2hpdGUtc3BhY2U6IHByZS13cmFwOwp9Cg=="},{"version":3,"sources":["Timeline.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgLA;AACA;AACA","file":"Timeline.vue","sourceRoot":"src/components","sourcesContent":["<template>\n  <div>\n    <Indeterminate v-if=\"loading\"/>\n    <v-timeline v-else dense>\n      <v-timeline-item v-for=\"(item, i) in postList\" :key=\"i\" large>\n        <template v-slot:icon>\n          <v-avatar>\n            <img :src=\"imgURL[usersData[item.uid].img]\">\n          </v-avatar>\n        </template>\n        <template v-slot:opposite>\n          <span>Tus eu perfecto</span>\n        </template>\n        <v-card class=\"elevation-2\">\n          <v-card-title class=\"headline\">{{ usersData[item.uid].name }}</v-card-title>\n          <v-card-text class=\"content\">{{ item.content }}\n          </v-card-text>\n\n        </v-card>\n      </v-timeline-item>\n  </v-timeline>\n  </div>\n\n</template>\n\n<script>\nimport firebase from 'firebase/app'\nimport 'firebase/database'\nimport 'firebase/storage'\nimport Indeterminate from './Indeterminate'\n\nexport default {\n  data() {\n    return {\n      loading: true,\n      postList: [],\n      usersData: {},\n      imgURL: {}\n    }\n  },\n  components: {\n    Indeterminate\n  },\n  created() {\n    // めっちゃエラー起きるけどsetTimeoutでごり押ししてます なんか良い解決法ないかな <= async/await\n    // firebaseとの通信終わってから<template>読み込むようにすれば良いんだと思う\n    // Promiseでループ処理するためになんか変なの使ってる Promise使ってるくせに見通しクソです\n    // ソース => 'https://blog.htmlhifive.com/2016/02/22/promise-async-loop/'\n    let database = firebase.database()\n    let storage = firebase.storage()\n    let self = this\n\n    // Promiseで非同期処理するゾ\n    let result = new Promise(function(resolve) {\n      // postsData(uid, content)の取得\n      let posts = database.ref('/posts')\n      posts.on('value', (snapshot)=> {\n        let postList = []\n        let val = snapshot.val()\n        // 連想配列をループで展開して配列にする\n        Object.keys(val).forEach(function(key) {\n          postList.push(val[key])\n        })\n        console.debug(val)\n        console.debug(postList)\n        self.postList = postList.reverse() // this.postListに代入 ついでに反転\n        //resolve(val)\n        resolve(postList)\n\n      })\n    })\n    result.then( function(datas) {\n      console.debug(datas)\n      // データベースのpostsを受け取りループで展開してuidを取得 それにfilterかけて次に回す\n      new Promise(function(res) {\n        let list = []\n        // ここにループさせる関数\n        // datasのdataを受け取ってuidを返す\n        function makeList(index) {\n          return new Promise(function(resolve) {\n            console.debug(datas[index])\n            list.push(datas[index].uid)\n            resolve(index+=1)\n          }).then(function(index) {\n            // ループを抜けるかの判定\n            if (index >= datas.length) {\n              // 抜ける 重複を弾く\n              list = list.filter((x,i,self) => self.indexOf(x) === i)\n              res(list)\n            } else {\n              // 再起的に実行\n              makeList(index)\n            }\n          })\n        }\n        // 初回実行\n        makeList(0)\n      }).then(function(list) {\n        console.debug(list)\n        // 受け取ったuidのlistをループしてfirebaseからデータを取得 this.usersDataにぶち込む\n        let imgList = []\n        new Promise(function(res) {\n          function getUserData(index) {\n            let uid = list[index]\n            return new Promise(function(resolve) {\n              let user = database.ref(`/users/${uid}`)\n              user.on('value', (snapshot)=> {\n                let val = snapshot.val()\n                console.debug(uid)\n                self.usersData[uid] = val\n                imgList.push(val.img)\n                resolve(index+=1)\n              })\n            }).then(function(index) {\n              if (index >= list.length) {\n                // 抜ける filterかける\n                imgList = imgList.filter((x,i,self) => self.indexOf(x) === i)\n                res(imgList)\n              } else {\n                getUserData(index)\n              }\n            })\n          }\n          // 初回実行\n          getUserData(0)\n        }).then(function(imgList) {\n          console.debug(imgList)\n          // 受け取ったimgListを展開してURLを取得する this.imgURLに{uid: 取得したURL}の形でぶち込む\n          new Promise(function(res) {\n            function getImgURL(index) {\n              let img = imgList[index]\n              return new Promise(function(resolve) {\n                // URL取得\n                let imgRef = storage.ref(`/${img}`)\n                imgRef.getDownloadURL().then((url)=> {\n                  let xhr = new XMLHttpRequest()\n                  xhr.responseType = 'blob'\n                  xhr.onload = ()=> {\n                    let blob = xhr.response\n                    self.imgURL[img] = URL.createObjectURL(blob)\n                  }\n                  xhr.open('GET', url)\n                  xhr.send()\n                  resolve(index+=1)\n                }).catch(function(error) {\n                  console.debug(\"GetImgURL Error\",error)\n                })\n              }).then(function(index) {\n                if (index >= imgList.length) {\n                  // 抜ける\n                  res()\n                } else {\n                  getImgURL(index)\n                }\n              })\n            }\n            // 初回実行\n            getImgURL(0)\n          }).then(function() {\n            // 処理終了 結果のログ出力 ごり押しsetTimeout\n            console.debug(\"GetTimeLineFinish!!!\")\n            console.debug(\"postList\", self.postList)\n            console.debug(\"usersData\", self.usersData)\n            console.debug(\"imgURL\", self.imgURL)\n            setTimeout(() => {\n              self.loading = false;\n            }, 1000);\n          })\n        })\n      })\n    })\n  },\n}\n</script>\n\n<style scoped>\n.content {\n  white-space: pre-wrap;\n}\n</style>\n"]}]}